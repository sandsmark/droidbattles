
<!doctype linuxdoc system>
<article>
<title>The BattleBots Handbook
<author>Andreas Agorander <tt>Bluefire@bluefire.nu</tt>
<date>Version 1.0.0 , Mar 25 2001
<abstract>
This Handbook describes BattleBots Version 1.0.0
</abstract>

<toc>

<sect>Introduction
<p>
<sect1> General Description
<p>

BattleBots is a programming game for the Linux/UNIX environment.
You design and program bots (in an asm-like language) in order
to make it better then anyone elses bot. You then run the bots
in a battle simulation, where they try to kill each other.

<sect1>Changes
<p>

<sect>Installation
<p>
<sect1>How to obtain BattleBots 
<p>
BattleBots is available at this adress:
http://www.bluefire.nu/battlebots/

<sect1>Requirements
<p>
The following is needed for BattleBots to compile and run:
<tscreen><verb>
qt 2.x (tested on 2.2.3) devel version
X-windows (tested on 4.0.2) with headers installed
A unix system (tested on SuSE Linux 7.1)
A c++ compiler (tested with gcc 2.95.2)
make
autoconf
</verb></tscreen>

<sect1>Compilation and installation
<p>

In order to compile and install BattleBots on your system, type the following in
the base directory of the BattleBots distribution:

<tscreen><verb>
% ./configure
% make
% make install
</verb></tscreen>

<p>
If you want to have battlebots installed somewhere else than /usr/local ...
you should run the install as above, then copy all folders to the new
location and then edit line 2 of /etc/battlebots.conf

<p>
Since BattleBots uses <verb>autoconf</verb> you should have not trouble
compiling it.
Should you run into problems please report them to the the author
<htmlurl url="mailto:Bluefire@bluefire.nu" name = "Andreas Agorander">


<p>
<sect> Getting started: crash course <p>

<sect1> Quick start: Creating bots
<p>
This section is intended for people without the patience to go through the entire
documentation to get started. The "crash-course" tutorial will go through the
steps necessary to create a simple bot going around in circles capable of
discovering and shooting at adversaries.

Since we will create a bot you should bring up the "bot-creator" window.

The first step in creating the bot is deciding which hardware a bot
should have.
Our program won't be that big, so 1k of RAM is enough for us.
All bots need at least one CPU, choose CPU in the uppermost combobox.
The five buttons below the combobox decides the "level" the device is
at. In the case of the CPU, it decides the speed of the CPU.
You can choose anyone you want, and test the differences it makes in
the behaviour of the bot later.

The next device we need is an engine, we don't want to be sitting ducks
do we? Choose engine in the second hardware entry.

Add (in this order) these devices:

<tscreen><verb>
steering (makes your bot turn),
plasmagun (the weapon),
scanner (what we use for finding the enemy),
armor	(So that we can take some beating before blowing up),
armor,
fuel (Provides fuel for the engine),
fuel
</verb></tscreen>

Here is the code we need to write for our bot:

<tscreen><verb>
out 17,24
:loop
out 4,50

out 16,1
hwait
in ax,16
cmp ax, 60000
jae next

out 12,1
:next
out 8,4
jmp loop
</verb></tscreen>

it begins with this: out 17,24
each device has up to 4 inports and 4 outports.
You access these with the asm commands in and out.
Which ports a certain device has access to depends
on the number of the device.

The first device (CPU in this case) has ports 0 through 3
Engine has 4 through 7 and so on.

port 17 is the second port on our scanner, and it sets the
width of the scanner.
In this case we set it to 48 botgrades (24*2=48)
1 botgrade is 1/1024 of a circle.

The next line reads :loop.
It's a label , all labels start with ':'

The next line: out 4,50
Sets the thrust of our engine to 50, our bot will accelerate
to a speed of 50 units per turn.

out 16,1
Orders the scanner to emit a scan pulse, searching for other
bots.

The hwait makes sure the result from the scan has time to get
in before we try to read the result

in ax,16
gets the scanned distance and puts it into CPU register ax

cmp ax,60000
Compares the value in ax with 60000 (if no bot was in our
scan-arc, the value will be above 60000)

jae next
Jump if Above or Equal, jumps to next if no bot was in
our scan arc

out 12,1
Orders the plasmagun to shoot

:next
A label

out 8,4
Orders steering device to turn 4 botgrades to the right

jmp loop
Jump to label loop

If you understand this example, you are well on your way
to make your own bots.

Save this bot under the name "circles.basm".
click on assemble under the assemble menu.
If you wrote something wrong the assembler will complain
but otherwise it will tell you "assemble successful".

Now you can test the bot in the simulator
It will be named "circles.bot".

<sect1>Quick start: simulating<p>

A quick way to see your new bot in a simulation:
bring up the "normal battle".

Press load bot, if you assembled your bot a file named "circles.bot"
should exist, choose it.

In order for a simulation to start you need at least 2 bots loaded. So you may
either load the circles.bot again or load a different bot.

Then when you press OK, a battle will start immediately.

<sect>The way BattleBots works<p>

<sect1>The arena<p>
The arena is the square area where the bots fight. The size of the arena is
decided at the time the simulation is started, but it is somewhere between
8192 - 65536 units on each of the axis. One pixel on the screen is 64 units in the game.

In the arena there is room for a multitude of objects. The most important are the up
to 8 bots that fight for supremacy. But other objects also existing are objects
released by the bots (as for example shots).

<sect1>The bots<p>
The 'bots' are our main object of attention here. They are 'modules' designed and
programmed in order to rule the arena.They consist of two main parts: The hardware
chosen, and the program that makes use of and steers the hardware. When you create
your bots you have a certain number of slots available, where you can choose to
put any of some 20 different sorts of hardware. (Assuming the config allows them).
You also choose how good version of the hardware you want.

When you have chosen all the hardware you must write a program in "bot ASM" to steer
the hardware. An intel x86:ish asm language adapted for this purpose. (Actually, there
might be "compilers" for higher level language available, but they are a different story).

When the simulation is running, the CPU devices you have included in your bot executes
the program you wrote. Firing weapons to inflict damage on each other the bots eventually
get killed. This occurs when the damage absorbtion devices of a bot is unable to take
care of all damage that comes in. The most important value here is the 'armour value'.

This value is the amount of armour your bot has left, if a hit removes more armour then
you have, your bot dies.
However, not only enemy activity can remove your armour; Many activities of your bot
generates "heat". Letting the heat go high will also burn off armour. Though it won't
kill your bot directly, the bot is then very vulnerable to even the smallest hit.

Some hardware is virtually necessary for your bot (CPU,scanner,armour etc...) and some
hardware is entirely optional. It's up to you to decide what is needed.

<sect1>Config Rules<p>
For tournaments, and sake of comparison it might be good to regulate the designs of
the bots somewhat. This is done in a config file, and is enforced as such:

All devices cost 'money' and takes a slot in your bot. The config file defines the
number of slots available as well as the total amount of money your bot is
allowed to cost. It also defines how much each of those devices cost at each of the
five version levels.

If you try to start a simulation with a bot that breaks the config rules the
simulator will notify you of that.

As such. When you create your bots, you might want to keep a certain config in mind.
Perhaps the config is one of a special tournament running on the net, or one that
your friends and you agreed upon for your personal rumbles.

<sect>The bot-creator<p>
The botcreator is probably where you will spend most of your time with BattleBots.

<sect1> Components of bot creator<p>

The bot-creator consists of five fields:

-The menu
-The cycle counter
-The program window
-The hardware window
-The picture window

The first thing you should do when you create your bot is decide upon the hardware.
In the rightmost frame you choose the amount of RAM (decides how big program you can
make) and selects up to 32 hardware devices. Each of the hardware slots has a number
of settings:

In the combobox you select the sort of device you want. The five buttons below sets the
"level" , or how good the device is. The white box can contain special arguments that
some devices need (for example the turret). The cost of every device is shown (as checked
against current.cfg). The "info" button gives information on in/out ports for that device.

When you've chosen all the hardware it might be time to do the programming. Code is entered
in the largest white field. To compile the code to a bot that can be simulated you should
press Assemble under the menu Assemble. When you assemble your bot the smaller textfield
to the left of the editor is filled with numbers, those are counts of how many cycles
it will take for the CPU to execute each line of code.

If you want to check if your bot breaks any of the rules in the config press:
"Check against Config" in the Tests menu.

It might be a good idea to use "Quick Battle" when you develop your bots. This is a feature
where you define a number of predefined contestants (this is done with "config quick battle").
Then all you have to do to test your "in development" bot in battle is press "Quick battle".

A Quick Battle starts in a paused state. This is because you might want to see what happens
with the register contents or other stuff for debug purposes. So a "debug" window is shown
where contents of registers and of some memory locations are shown. In addition the
debugwindow has a white box where instructions executed by your bot the latest round is
shown. This feature only works if you've "assembled" just before you started the
simulation (regardless of whether you actually made any changes!). Also a "dumpmem"
button is present. When you press this button the contents of your bots RAM is dumbed to
a binary file. The name of this file is of the form: BBdump#.bin, where # is he number of
the first "free" (eg. nonexistant) file between 0 and 255.

The final field is the button at the bottom of the window. Here you can load the graphics
that you want your bot to have.
The botgraphics consists of a number of pictures 32x32 in size. You can have rows and columns.
Each column contains the pictures for the bots at a slightly different angle, and if you have
several rows, the bot will "animate" between the rows as he travels.



<sect> The BattleBots assembler language
<p>

The bots are programmed using asm, here I will go through the basics...

<sect1>Basics of the mnemonics<p>

All the real work is done by assembler 'mnemonics' These are instructions like for example
mov, add, in or out. Each mnemonic has between 0-3 arguments.

Which argument combinations are possible depend on the instruction; but in general there are
four different types of arguments:

registers
registers pointing to memory,
value
memory adress

Registers are small memory cells within the CPU (that DON'T exist in RAM).
Some of them are "general purpose registers" and can be used for almost
anything,  some of them are used for special purposes... they are
either 16 or 8-bit here's a short list:

ax : general purpose register, also used by some instruction as result
containers (div, mul, idiv, imul), it's also used by STOSW as the source of the value
ah : the high byte of AX, Used by STOSB as the source
al : the low byte of AX

bx : general purpose register
bh : high byte of bx
bl : low byte of bx

cx : general purpose register, used as counting register for some instruktions that needs
     to know how many iterations they should make (STOSW,STOSB,MOVSB,MOVSW,CMPSB)
ch : high byte of cx
cl : low byte of cx

dx : general purpose register, used as result register for some instruktions (DIV,MUL)
dh : high byte of dx
dl : low byte of dx

eip : Instruktion Pointer, points to the current point of execution in RAM

sp : Stack Pointer, points to the current stack point in RAM

bp : Base Pointer, general purpose register (often used as temporary save for sp)

si : Source Index, used as memory pointer, (MOVSB,MOVSW,CMPSB)

di : Destination Index, used as memory pointer, (MOVSW,MOVSB,STOSW,STOSB,CMPSB)

flags : contains the state flags for the CPU

Registers pointing to memory is a register with an @ before it:

mov bx,100 ;100 -> bx
mov ax,@bx ;Mov the contents of memory cell 100 to ax

Values is just that...:

mov bx,100

Note that pure values can't be the destination in an instruction

Memory adresses are values with an @ before it:

mov ax,@100 ;Mov the contents of memory cell 100 to ax

<sect1>Symbols:<p>
In most places where you use values you can use constants/symbols/labels:

$myconst 45
Declares a constant with the name 'myconst' and the value 45. It can be used as such:

mov ax,@myconst  ;Move contents of memory cell 45 to ax
mov ax,myconst   ;Move value 45 into ax

:label
Declares a constant with the name 'label and the value of the position in RAM that the current
assembly point is at. This is useful for jumping in code:

:label
mov ax,bx
add dx,cx
jmp label

(Nothing stops you from doing 'jmp myconst' or 'jmp 100' or mov ax,label but it's not
recommended)

#variable
Functions about the same as :label, it defines a constant named 'variable' with the value of
the current position in RAM. It is intended for declaring variables:

#myvar
dw 5

mov ax,myvar puts the _ADRESS_ of myvar into ax and
mov ax,@myvar puts the _CONTENTS_ of myvar int ax

There are a number of predefined constants (from version 0.4.1). These are named after your
hardware and contains the values of the ports they use:

If you have two CPU:s and they are devices 0 and 5 the following constants are automatically
declared:
Name         Value
CPU0_GetXSize 0
CPU0_GetYSize 1
CPU0_GetBattleType 2
CPU0_GetMyTeam 3

CPU1_GetXSize 20
CPU1_GetYSize 21
CPU1_GetBattleType 22
CPU1_GetMyTeam 23

All hardware gets symbols declared like this. If you change your mind and want the second
CPU in slot 3 instead you would have to change all the values in your code if you didn't
use these constants.

This way your code won't be depending on the exact number of your device. (And will as such
be more portable between different "hardware"). Not to mention it gets easier to read.

<sect1>The "Red Tape" tags:<p>

"Red tape" tags are code that in general doesn't assemble directly into runnable code
but instead affect how the following code is generated.

%org number
All code and such is placed in the RAM mem of the bot.
%org number makes the code that comes after to start being
assembled to position number.

Example:

nop
nop
%org 100
nop
nop

If this is the only code in the bot then nop:s are inserted at
positions 0,1,100 and 101 in the RAM memory

also, you can make a relative org.
Example:

%org 0
nop
nop
%org 100
nop
nop
%org +100
nop

nop:s are inserted at positions 0,1,100,101 and 202

%CPUboot devicenumber

This tag makes the device devicenumber (assuming it is an CPU) to
boot at the current position in the code.

example:

%CPUboot 0
:start
...
...
...
...
jmp start

%CPUboot 1
:navigate
...
...
...
...
...
jmp navigate

This causes the CPU:s to execute "simultaneously" in different functions
in the code.

%CPUstack devicenumber:
If you use PUSH/POP/CALL or something like that you must set this.
It functions as %CPUboot only this one sets stack mem.
If it isn't set stackmem will default to 0.
And in that case it WILL overwrite code if you execute a PUSH.

%interrupt interruptnumber:

If certain events occur, the hardware can
"interrupt" the current CPU computing and take it to a "service routine".

Example bot :

Hardware:

CPU
Plasmagun
timedev

code:

:start
cli       ;No interrupts when we initialize
out 8,0   ;Set the timers current tick count to 0
out 9,100 ;Set the interrupt count to 100
out 10,1  ;enable this device interrupt
sti       ;enable interrupts

:loop
jmp loop  ;infinite loop

%interrupt 1 ;Here the code for interrupt 1 (timer interrupt) starts
:service

out 8,0   ; reset clock count
out 4,1   ; shoot

iret
%CPUstack 0

This code will make the bot fire a shot every 100 clock ticks.
Available interrupts are:

0: Collision/hit (issued by armor device)
1: Time interrupt (issued by timedev)
2: Message received (issued by radio)
3: Armor below a certain level (issued by armor dev) !OBS only enable this int in ONE armor device
4: Fuel below a certain level (issued by fuel dev) !OBS only enable this int in ONE fuel device
5: Heat above level interrupt (issued by armor dev) !OBS only enable this int in ONE fuel device

If you have multiple CPU:s the first CPU with the interrupt flag set
will get the int (set the flag with sti, clear it with cli).
If no CPU has the interrupt flag on, no interrupt is issued.
Entering an interrupt clears the interrupt flag, and executing
an iret sets the interrupt flag.

Remember that you need to specify CPUstack if you use interrupts, as
the adress of where the CPU where when he got interrupted is saved on
the stack.

The adresses of your interrupt vectors are stored at the end of your RAM,
So if you use interrupts 0 & 1 you shouldn't do something with the 4 last
bytes of your RAM

db/dw:

declare byte/declare word...
Sets the current bytes to the values after db/dw.
You may have up to 12 values after each db/dw

example:

db 0,1,200,3,4,5,4,3,2,1
dw 12045,10000,14000,950

comments:

comments is started with the ; sign

example:
; This is a comment
  nop        ;wait
;  ^           ^
; mnemonic   comment

<sect> Running simulations<p>

There are several built in ways to run battles and tournaments, here we will go through
them one by one.

<sect1> Running normal battle simulation
<p>

<verb>
1. Make sure that the bots you want to simulate are compiled.
In case they're not, load up the bot creator, load the bot
source and press assemble. When the assembler tells you
assemble successful the bot is compiled.

Also, make sure the correct config file is loaded. Do this by
firing up the config editor, press load existing config. Then
load the correct config (the standard ones are under
/usr/local/battlebots/.. ), and then apply current config.

2. Press start single battle.

3. Press load and choose the correct .bot file

4. repeat step 3 until all the bots you want to simulate are loaded
(max 8).

5. Choose how many battles the bots should go

6. Choose the maximum time before a draw is called

7. Choose the X and Y size of the battlearea

8. If you want to run a team-battle, toggle the team-checkbox
   And then choose the teams for all bots (the comboboxes with values 1-4 in)

9. Press OK


Also, if you want to test your bots quickly as you edit them you can use the
quick battle feature in the bot-creator. You need to configure the quick battle
function once, but after that all you have to do is assemble the bot and press
quick battle and your bot is in a fight.

Also when running a quick battle a debugwindow with some basic info (register
contents, mem contents etc...) is shown.

</verb>

<sect1> Running survival battle simulation
<p>
<verb>
A survival battle is started almost the same way as a normal battle. There are
no team option in survival ,but there is a fast battle choice.
No "number of fights" option but instead a number of lives.

In actual combat the difference between normal and survival is that when you die
in survival, you get your number of lifes decreased, and then (if you're not out
of lifes) respawn, with a new fresh bot. The last bot with lives left wins. (Or
if time runs out, the bot with the most lives left wins).

</verb>

<sect1> Running deatchmatch battle simulation
<p>
<verb>
A deathmatch battle is started almost exactly as a survival battle.
Only, instead of "number of lives" you select "number of frags".
That is, How many frags a bot should get in order to win (and the
battle end).

</verb>

<sect1> Running league tournaments
<p>
<verb>
1. Make sure that the bots you want to simulate are compiled.
In case they're not, load up the bot creator, load the bot
source and press assemble. When the assembler tells you
assemble successful the bot is compiled.

Also make sure the correct config is loaded.

2. Press start tournament.

3. Press load and choose the correct .bot file

4. repeat step 3 until all the bots you want to simulate are loaded
(max 64).

5. Choose how many battles the bots should go

6. Choose the maximum time before a draw is called

7. Choose the X and Y size of the battlearea

8. If you have many bots in you might want to check the "fast battles"
   checkbox, in order to have the battles go VERY fast.

9. Press OK

In a tournament, the bots go one on one, and all bots in the tournament
meets. This means that If there are 4 bots in the tourney, 6 matches will
be played. Be warned that this number increases rapidly. If n bots are in
the tourney and each match consists of f fights this formula applies:

total fights = ((n^2-n)/2)*f
for n = 16 bots and f = 5 fights this means:
total fights = ((16^2-16)/2)*5 = 600 fights.

For this, I have included the "fast battles" option in tournaments. The battles
will go quite fast (on a fast computer that is), but you won't see much of the
battles.

The result of the tournament is NOT put out on the screen directly. Rather it
is output to tournament.html in an HTML formatted table document.
</verb>

<sect1> Running KOTH tournaments
<p>
<verb>
KOTH tournaments is started in the same way as league tournaments.
But the actual battles fought are different.
In the first battle the two bots at the bottom fight, the loser is put
on the lowest rank while the winner challenges the bot above.

And so it continues, the winner in the battles continue moving up in the
table and the loser stops in the table. This way a bot can in a single
KOTH tournament run gain positions all the way to the top, but a bot
can only lose one position in a single round.

When all fights the way up to the top have been fought the results are
written to two files: One HTML formatted file (Kothresults.html)containing
the new table and the list of all matches that had been run in this round

One file named currentKOTH.table which contains the current table and other
options set in the start KOTH window.

When you want to run the next round you should press "load list" button in
the startKOTH window and select currentKOTH.table (or what you renamed that
file to). and then all you have to do is press start and a new round is fought.

</verb>

<sect1> Running Cup tournaments
<p>
<verb>
Cup tournaments is started the same way as League tournaments.
However, the number of bots must be either: 4,8,16,32 or 64.
The actual battles fought are also different. The bots pair up one on one and
fight. The winners go through to the next round, and the losers is out. This way
it goes until only one bot is left (that wins). The results, with all battles
fought is written to the file Cupresults.html.
</verb>


<sect> Creating your config
<p>

<verb>
In the config editor you can edit the allowed configurations of the bots.
If you want to have som "sane" values to start with press "load default
values".

The first setting sets how many devices a bot should be allowed to have.
The maximum is 32.

The second is the maximum "cost" of the bot. Each device cost "money" and
the cost can be different for different devices.
And the costs should be different for different levels of a device.
To ensure that you can't allways take the best level of all devices but
instead force some tactics into the design of the bots this value should
be balanced.

The next setting is the maximum amount of RAM usage that should be allowed...
The more RAM that's allowed, the more code and data-tables and such can be
used.

And in the editable combobox you can set the cost of RAM for each amount.
The first element corresponds to the first amount of RAM and so on.

Then comes the settings for each device.
There are currently three settings available (more to come).
1. If the device is allowed to use

2. The cost of the device at each of the five levels.

3. The value for the device at each level.
This setting means different things for different devices, so here is a list:

CPU: The number of cycles the CPU has each round
Engine: The maximum speed
steering: the number of botgrades it can turn each round
plasmagun: the reload value for the gun (the higher, the faster he reloads)
armor: The amount of armour he gives you
scanner: maximum length of scanarc
fuel: amount of fuel
chaff: amount of chaffs available
turret: turnrate per cycle
scanwarner: N/A
timedev: N/A
shield: percentage of damage absorbed
repair: countdown value till next reparation (lower means faster repair)
radio: N/A
minelayer: amount of mines
missile: Countdown value till next fire (lower means faster rate of fire)
beam: Amount of heat generated firing a shot
AS-Rocket: Decrease in readiness for each fires rocket (lower means faster fire)
cloaker: Amount of cloaking (decrease in radar signature)
Chiller: Amount of cooling effect each round

When you've created and saved your configs you can make them the currently used
configs by pressing "Apply current config".

</verb>

<sect> Details of devices
<p>

This section provides more details of all the hardware
available to the bot...

In the port listings first the name of the port is listed and then a ddescription.
The name is the predefined constant of the port and is of this form:

CPU#_GetXSize

First the name of the hardware,
# stands for the number of the hardware eg. the first CPU has a 0 there and the fifth has a 4
 there. Then after that comes _ with the name of the port

<sect1>CPU:<p>
<tscreen><verb>
The CPU device is the device that runs the actual program.
It can execute numerous opcodes.

In addition to that it can take two parameters:

%CPUboot and %CPUstack

..
..
nop
nop

%CPUboot 0
:label
nop
nop

%CPUstack
:label2

This means that the first device CPU will boot at position :label
and that it's stack memory starts at label2
This is especially important if you use multiple CPU:s

inports:
first: CPU#_GetXSize, get X-size of battlearea
second: CPU#_GetYSize, get Y-size of battlearea
third: CPU#_GetBattleType, get type of battle (0-normal,1-survival,2-deathmatch)
fourth: CPU#_GetMyTeam, get team/frequency of your bot.

</verb></tscreen>

<sect1>Engine:<p>

<tscreen><verb>
The engine device is what regulates with what speed your bot moves

outports:
first: Engine#_SetThrust, set the wanted speed
second: Engine#_SetReverseThrust, set the wanted reverse speed

inports:
first: Engine#_GetThrust, get the current thrust level
second: Engine#_GetSpeed, get the current speed
</verb></tscreen>

<sect1>Steering:<p>

<tscreen><verb>
The steering device makes your bot turn

It can steer a certain number of botgrades each round (determined by config).
There are 1024 botgrades on a circle, and the botgrade 0 is straight to the right.

outports:
first: Steering#_AdjustWantedDir, adjust-heading, The value is relative to the
current aimed heading and is in botgrades, To turn right 8 botgrades: out 0*,8
To turn left: out 0*,1016

second: Steering#_SetDir, Aim at absolute heading
out 1*, 512 ;Go straight left

third: Steering#_AdjustCurrentDir, Sort of like the first, but the value isn't
relative to the aimed heading, but relative to the current "real" heading. This
can prevent the "overflow" problem...

* Adjust for the position of the device

inports:
first: Steering#_GetDir, get current dir
second: Steering#_GetWantedDir, get current wanted dir
third: Steering#_GetXpos, get X-position
fourth: Steering#_GetYpos, get Y-position
</verb></tscreen>

<sect1>Plasmagun:<p>

<tscreen><verb>
The plasmagun is a weapon

outports:
first: Plasmagun#_Shoot, fire shot
inports:
none
</verb></tscreen>

<sect1>Armor:<p>

<tscreen><verb>
The armor provides protection against enemy weapons
If hit when no armour is left, the bot dies

outports:
first: Armor#_SetCollIntEnabled, hit/collision interrupt enable/disable
second: Armor#_SetArmorIntEnabled, armor below level interrupt enable/disable
third: Armor#_SetArmorIntLevel, set level for armor interrupt
fourth: Armor#_SetHeatIntLevel, set level for heat interrupt

inports:
first: Armor#_GetArmor, Amount of armor for bot
Second: Armor#_GetHeat, Amount of heat for bot (>500 and armor starts burning off)
</verb></tscreen>

<sect1>Scanner:<p>

<tscreen><verb>
The scanner searches an area for enemy bots

outports:
first: Scanner#_Scan, emit scan pulse (update distance and acuracy registers)
second: Scanner#_SetScanWidth, set width of scanner
third: Scanner#_SelectReturn, select what the fourth inport should return
	0:frequency of bot last scanned
	1:number of object last scanned
	2:direction of object last scanned
	3:speed of object last scanned
fourth: Scanner#_SetSensitivity, Set sensitivity for scanner
Decides what kind of objects the scanner sees.
level 5 sees only bots and chaffs
level 4 sees above and missiles
level 3 sees above and mines
level 2 sees above and rocket
level 1 sees above and plasmashots

inports:
first: Scanner#_GetScanDistance, get distance to bot in last scan (65535 if none was found)
second: Scanner#_GetScanAccuracy, Get accuracy of last scan. Returns a value (0-4) .
If the enemy bot was in the middle of your scan it returns 2, if
it was to the leftmost 0 and to the rightmost 4.
third: Scanner#_GetScanWidth, return current width of scanner beam
fourth: Scanner#_GetScanInfo, Return one of the four things set by the third outport

</verb></tscreen>

<sect1>fuel:<p>

<tscreen><verb>
Provides fuel for the engine.

outports:
first: Fuel#_SetFuelIntEnabled, set fuel below level interrupt enable/disable
second: Fuel#_SetFuelIntLevel, set level for interrupt

inports:
first: Fuel#_GetFuel, Get fuel amount

</verb></tscreen>

<sect1>Turret:<p>

<tscreen><verb>
Can "turn" other devices around even if the bot stands still.
The only devices that currently can be turned are scanner,
plasmagun, AS-Rocket and missile. The turret needs the number
of the device it is it should turn in the white box beside the
combo-box.

outports:
first: Turret#_SetOffset, put at absolute offset (offsets device an absolute number
from the bots heading)
second: Turret#_AdjustOffset, put at relative offset (offset device a number from the
current offset)

inports:
first: Turret#_GetOffset, return current offset
second: Turret#_GetWantedOffset, return current wanted offset (in case it hasn't had the time
to move all the way...)
</verb></tscreen>

<sect1>Time-device:<p>

<tscreen><verb>
This is a ticking clock
It ticks once every combat round (~ 50 ticks per second)

outports:
first: Timer#_SetTime, Set current time tick
second: Timer#_SetIntTime, Set time for interrupt
third: Timer#_SetIntEnabled, Interrupt enable

inports:
first: Timer#_GetTime, Get current time
second: Timer#_GetIntTime, Get interrupt time
third: Timer#_GetIntEnabled, Get interrupt enabled
</verb></tscreen>

<sect1>Shield device:<p>

<tscreen><verb>
This device stops a percentage of all incoming damage.
It doesn't get damaged itself, but it uses fuel whenever
it's up

It uses 5 fuel for every round it's up (should I increase this?)

outports:
first: Shield#_SetShieldEnabled, Up with shield/down with shield (1 is up, 0 is down)

inports:
first: Shield#_GetShieldEnabled, Get current state of shield (up/down)
</verb></tscreen>

<sect1>Repair device:<p>

<tscreen><verb>
This device (slowly) repairs the damage on your armor

It doesn't react to inports/outports
</verb></tscreen>

<sect1>Radio device:<p>

<tscreen><verb>
With this device your bots can communicate with all on
their own frequenzy. In team battle each team has it's
own frequenzy.


outports:
first: Radio#_SetReceiver, Set receiver (Sets bot, on your team that should receive msg:s)
255 means all on your freq (incl.you) receives it.

second: Radio#_SendMsg, Send number (sends a number to receiver
third: Radio#_SetMsgIntEnabled, set message received int enabled/disabled

inports:
first: Radio#_GetNumMsgs, Gets the number of msgs in queue
second: Radio#_GetMsg, Get first number in queue
third: Radio#_GetMyNum, Get my number
</verb></tscreen>

<sect1>Minelayer:<p>

<tscreen><verb>
This device lays small explosive devices on the ground that explode on
impact.

Each mine can make 70 damage

outports:
first: Minelayer#_LayMine, lay mine

inports:
first: Minelayer#_GetMines, get mines left
</verb></tscreen>

<sect1>Missile:<p>

<tscreen><verb>
This is a programmable missile, it contains (in this order) a CPU,steering
and a scanner device that you can control programmatically. You need to
tell it where in your ram it's CPU should boot, and if needed where it's
stackmem is.

outports:
first: Missile#_SetBootPos, set bootposition
second: Missile#_SetStackPos, set stackposition
third: Missile#_FireMissile, fire missile

inports:
first: Missile#_GetLoadTime, return reloadtime (if this is != 0 you can't fire)

example: (assuming missile is first device)

:start
...
...
mov ax,missileboot
out 0,ax
mov ax,missilestack
out 1,ax
nop
nop
nop
out 2,1 ;Fire missile
...
...
...
jmp start

:missileboot
...
... (missile steer code)
...
jmp missileboot

:missilestack
</verb></tscreen>

<sect1>beam<p>
<tscreen><verb>
The beam is a short range weapon, you set the exact dir and distance for
the aim and an almost immediate hit is issued when you fire.Maximum
distance is 8000 units.

outports:
first: Beam#_FireBeam, fire beam
second: Beam#_SetBeamDir, set dir of beam (you don't need turret for that)
third: Beam#_SetBeamLength, set length of beam

inports:
first: Beam#_GetDir, return dir
second: Beam#_GetLength, return length

</verb></tscreen>

<sect1>AS-Rocket<p>
<tscreen><verb>
AS-rocket is a weapon that as the beam have a certain distance set.
When it is fired it goes that distance then explodes giving all
objects nearby damage. The rocket is NOT affected by any other
objects on the way to the goal, so the only way to get away is to
move...

outports:
first: Rocket#_SetDistance, set distance
second: Rocket#_FireRocket, fire a rocket

inports:
first: Rocket#_GetReadiness, get readiness (max 200)
second: Rocket#_GetDistance, get distance
</verb></tscreen>


<sect1>chaff<p>
<tscreen><verb>
Chaff is a device that emits chaffs. That is , radar reflecting debris
that to enemy(and friendly) scanners appears to be bots, but really is
some sort of decoy. They live for 320 cycles before they dissolve.
They goes of in the same direction your bot is traveling (only at half your
speed).

outports:
first: Chaff#_ReleaseDebris, fire debris

inports:
first: Chaff#_GetDebris, get number of debris left
</verb></tscreen>

<sect1>Scanwarner/detector<p>
<tscreen><verb>
This device keeps a count of how many times you've been scanned and can give
you some info about te last scan against you.

outports:
first: ScanWarn#_ZeroCounter, zero counter

inports:
first: ScanWarn#_GetNumScans, return counter (number of turns scanned)
second: ScanWarn#_GetScanDir, return the approximate dir for last scan
( ~128 botgrades error margain )
third: ScanWarn#_GetScanIntensity, return "intensity" for last scan

This value is calculated by adding two values:
first value is a value over how much in center of the scan you were
(center means 0 points, on the edge means 2 points)
The second is a value of how near the enemy bot were when he scanned you, that is
if you were in his lowest third of his scanners range this value is 0 and if you are
almost at the edge of his range this value is 2.
the value returned is thus 0-4.
</verb></tscreen>

<sect1>Chiller<p>
<tscreen><verb>
This device helps cooling your bot each round. Even when doing passive cooling
it helps,but activating active cooling doubles the cooling effect. However,
active cooling uses fuel.

Outports:
first: Chiller#_SetExtraCooling, Set active cooling on/off

Inports:
none
</verb></tscreen>

<sect1>Cloak device<p>
<tscreen><verb>
This device lowers your radar signature, so that your bots appear to scanners to
be of the size of a smaller object. If enemy scanners have their sensitivity set
higher they wondt see you, however, enabling cloak will use fuel and generate heat

Outports:
first: Cloak#_EnableCloak, Set cloak on/off

Inports:
none

</verb></tscreen>

<sect>Details of instructions<p>

This section gives a detailed explanation of the available assembler
instructions.

<sect1>mov<p>

mov dest,source :
<tscreen><verb>
Copies a value from source to dest.
Source can be a register, memory referencing register,value or mem-adress.
dest can be a register, memory referencing register or mem-adress
(though you can't mov mem,mem)

example:

mov ax,100
mov @ax,100
mov ax,@100
mov @100,ax
mov ax,bx

It can also be a mov with an offset, example:

mov ax,@bx +4
mov @cx +3,dx ;These are the only two instructions taking 3 arguments

Observe that the mov with offset only works with exactly these operands
( reg,@reg +val and @reg +val,reg )


</verb></tscreen>

<sect1>nop<p>
<tscreen><verb>
Wastes a clock-cycle

Can be useful if you want to make sure that your out command is in
effect before you continue in your code.

</verb></tscreen>

<sect1>movsb/movsw<p>
<tscreen><verb>
Copies cx number of bytes/words from @si to @di.

Example:

mov cx,100
mov si, 50
mov di, 150
movsb       ;Copy bytes 50-149 to 150-249

movsw would have copied twice as much data
</verb></tscreen>

<sect1>stosb/stosw<p>
<tscreen><verb>
Fills cx number of bytes/words at @di with contents of ah

Example:

mov ah,0
mov di,100
mov cx,100
stosb      ;Zero bytes 100-199

stosw would have zeroed twice as much data
</verb></tscreen>

<sect1>lodsb/lodsw<p>
<tscreen><verb>
lodsb does the equivalent of:
mov ah,@si
inc si

lodsw does the equivalent of:
mov ax,@si
add si,2
</verb></tscreen>

<sect1>push<p>
push source :
<tscreen><verb>
PUSHes a value onto the stack, and changes the stackpointer to point
past the PUSHed value.

Example :

push ax ;save ax to the stack
push @ax ;save value ax points to on the stack
push 100 ;put value 100 on the stack
</verb></tscreen>

<sect1>pop<p>
pop dest :
<tscreen><verb>
POPs the value off the stack and changes stack pointer (used with push).

Example:

push cx   ;save cx

do something else with cx

pop cx    ;restore cx
</verb></tscreen>

<sect1>xchg<p>
xchg arg1,arg2 :
<tscreen><verb>
Exchanges the contents of arg1 and arg2.
arg1 MUST be a register, arg2 can be register,memory or
 memory referencing register

Example :

mov ax,5
mov bx,7
mov @5,8
xchg ax,bx  ; ax=7, bx=5
xchg ax,@100 ; ax=8, @5=7
xchg ax,@bx ; ax=7 @bx or @5 = 8
</verb></tscreen>

<sect1>test<p>
test arg1,bit :
<tscreen><verb>
Tests a single bit in arg1. If no value is given for bit,
cl is used. If bit is set, equality flag is set, otherwise
cleared.

Example :

mov cl,3  ;test bit 3
test flags
jz next  ;Jump to next if bit was set

or this works just as good:

test flags,3
jz next
</verb></tscreen>

<sect1>cmp/icmp<p>
cmp arg1,arg2 :
<tscreen><verb>
Compares arg1 with arg2. sets/clears the equality, above and
below flags depending on the value of the operands...

icmp treats the values as signed.

Example :

mov ax,100
:loop
inc ax
cmp ax, 200  ;When ax is 200, jump outside the loop
jz next

jmp loop

:next
</verb></tscreen>

<sect1>cmpsb<p>
cmpsb
<tscreen><verb>
Compares cl bytes at @di with @si, sets/clears the equality,
above and below flags.

Example:

mov cl,5  ;Check 5 bytes
mov di,100
mov si,200
cmpsb     ;Check if the 5 bytes at @100 are the same as @200
</verb></tscreen>

<sect1>jmp<p>
jmp val :
<tscreen><verb>
jumps to a position in RAM, often used with labels as the value.

Examples:

:label
...
...
...
jmp label

but nothing stops you from doing:

jmp 100  ;NOT RECOMMENDED!! use labels!

You can also use a register as the adress container:

mov ax,100
jmp ax ; Use with caution!

</verb></tscreen>

<sect1>jz,jnz,jae,jbe,ja,jb,cj,cjn<p>
jz, jnz, jae/jnb , jbe/jna , cj , cjn :
<tscreen><verb>
Conditional jumps... takes the latest flag modifying operation into
account (test, cmp, cmpsb), or the value of a register

jz dest : jump if equal
jnz dest : jump if not equal
jae dest : jump if above or equal
jnb dest : jump if not below (same as above)
jbe dest : jump if below or equal
jna dest : jump if not above (same as above)
ja dest : jump if above
jb dest : jump if below
cj reg dest: jump if register reg != 0
cjn reg dest: jump if register reg == 0
</verb></tscreen>

<sect1>lz,lnz,la,lb,lae,lbe<p>
lz/lnz/la/lb/lae/lbe reg
<tscreen><verb>
Loads either a 1 or a 0 inte register reg, depending on the state of the flags.
lz reg : 1 if equal (otherwise 0)
lnz reg : 1 if not equal
lae reg : 1 if above or equal
lnb reg : 1 if not below (same as above)
lbe reg : 1 if below or equal
lna reg : 1 if not above (same as above)
la reg : 1 if above
lb reg : 1 if below
</verb></tscreen>

<sect1>loop<p>
loop dest :
<tscreen><verb>

decreases cx, and jumps to dest if cx != 0.

Example:

mov cx,100 ;100 loops
:loopdest

...
...

loop loopdest
</verb></tscreen>

<sect1>call<p>
call dest :
<tscreen><verb>
Pushes the current position to the stack and jumps
to dest.

Example

:start

call dosomething
call dosomethingelse

jmp start

:dosomething
...
ret


:dosomethingelse
...
ret
</verb></tscreen>

<sect1>ret<p>
ret ,ret val:
<tscreen><verb>
ret Pops the position of execution from the stack and jumps there
see call for example

ret val also pops a number of bytes (val)
This is useful if you make generic functions that takes pushed arguments
example:

:start

push ax
push dx
call funk
...
...
jmp start

:funk
...
...
ret 4 ;return with 4 bytes used for arguments


</verb></tscreen>

<sect1>iret<p>
iret :
<tscreen><verb>
Same as ret except it enables interrupts too.
Used in interrupt service routines:

%interrupt 0
dosomething
iret

</verb></tscreen>

<sect1>cli,sti<p>
cli sti :
<tscreen><verb>
cli : Clear Interrupt flag (disable hardware interrupts)
sti : Set Interrupt flag (enable hardware interrupts)
</verb></tscreen>

<sect1>out<p>
out port,arg :
<tscreen><verb>
Sends value arg to port, this is the way to give your devices
orders to do something.

example:

out 10,ax
out 9,7

</verb></tscreen>

<sect1>in<p>
in reg,port
<tscreen><verb>
Gets value from port to register reg. Thisi is the way to get
info from your devices

Example :

in ax,10

</verb></tscreen>

<sect1>inc,dec<p>
inc arg / dec arg :
<tscreen><verb>
Increases/decreases arg with 1:

inc ax
dec @bx
inc @100
</verb></tscreen>

<sect1>add,sub<p>
add arg1,arg2 / sub arg1,arg2 :
<tscreen><verb>
Adds /Subtracts arg1 with arg2.
Result is in arg1 :

add ax,bx
sub cx,100

</verb></tscreen>

<sect1>and,or,xor<p>
and/or/xor arg1,arg2
<tscreen><verb>
Performs bitwise and/or/xor on operands
Result is in arg1

Example:

and ax,24
or ax,bx

</verb></tscreen>

<sect1>shr,shl<p>
shr / shl arg1,arg2 :
<tscreen><verb>
Performs a shift left/right on arg1 arg2 bits

Example :

shl ax,2 ;shift ax left 2 bits (same as multiply of 4)

</verb></tscreen>

<sect1>ishr,ishl<p>
ishr/ishl :
<tscreen><verb>
Same as above, except sign bit is preserved

</verb></tscreen>

<sect1>ror,rol<p>
ror/rol arg1,arg2 :
<tscreen><verb>
Rotates arg1 around arg2 bits.

Example :
ror ax,2 ;rotates the bits in ax 2 steps
</verb></tscreen>


<sect1>int<p>
int val :
<tscreen><verb>
Performs a software interrupt, with interrupt vector
val being called:

int 0 ;Perform int 0

</verb></tscreen>

<sect1>mul/imul<p>
mul/imul :
<tscreen><verb>
Performs a multiplication of ax and dx. the low 16 bits
of the result end up in ax, and the high 16 bits in dx.

mov ax, 1024
mov dx, 300
mul
(dx is now 4 and ax is 45056 I think (haven't double checked))

imul is the same as mul, except it uses signed math

</verb></tscreen>

<sect1>div/idiv<p>
div :
<tscreen><verb>
Performs an integer division of ax and dx. The integer part
of the result end up in ax, the rest is in dx.

mov ax,50
mov dx,7
div

(ax is now 7 and dx is 1 )

idiv is the same as div except it uses signed math

</verb></tscreen>

<sect1>sin<p>
sin :
<tscreen><verb>
It takes the value in ax (0-1024 botgrades)
And puts the sin value for it back in ax.
The sin value is formatted as -32768 to 32767 (as -1 to 1)

I would like to get some comments on how this instruktion
should be changed or something

</verb></tscreen>

<sect1>cos<p>
cos :
<tscreen><verb>
It takes the value in ax (0-1024 botgrades)
And puts the cos value for it back in ax.
The cos value is formatted as -32768 to 32767 (as -1 to 1)

I would like to get some comments on how this instruktion
should be changed or something

</verb></tscreen>


<sect1>sinfunc<p>
sinfunc :
<tscreen><verb>
This instruction uses 3 registers in this formula:

ax = ax + bx * sin dx
(dx is 0-1024 botgrades)

I would like some comments on the usefullness of this
instruktion...

</verb></tscreen>

<sect1>cosfunc<p>
cosfunc :
<tscreen><verb>
This instruction uses 3 registers in this formula:

ax = ax + bx * cos dx
(dx is 0-1024 botgrades)

I would like some comments on the usefullness of this
instruktion...

</verb></tscreen>

<sect1>atanfunc<p>
atanfunc :
<tscreen><verb>
This instruction takes relative coordinates and returns the
angle to those coordinates:
bx is used as the relative X and dx as relative Y.
result is in ax.
bx and dx are treated as signed values

mov bx, 100 ;100 units to the right and
mov dx, -80 ;80 units up
atanfunc    ;calculate angle
</verb></tscreen>

<sect1>rnd<p>
rnd :
<tscreen><verb>
This instruction puts a random number into ax. (It uses the stdlib function rand( ))
</verb></tscreen>

<sect1>hwait<p>
hwait :
<tscreen><verb>
This instruction decreases the current number of cycles to zero for the CPU.
In each "hardware cycle" the CPU has between 3-7 cycles. if you execute an out
instruction the effect is not applied until the next hardware cycle. The standard
way of doing this was to insert a number of nop:s after an out instruktion.
However you never knew exact how many nop:s would be needed, so you had to insert
the "worst case" number of nop:s. with the hwait instruktion you don't waste any more
cycles than necessary.
</verb></tscreen>

<sect1>sqr<p>
sqr :
<tscreen><verb>
This instruction calculates the square root of ax.
The integer part is in ax and the decimal part in dx.
example :
mov ax,90
sqr
;ax is now 9
;dx is now 31904
</verb></tscreen>

<sect1>msg<p>
msg adress:
<tscreen><verb>
This instruction sends a message that will be visible in the battle infowindow.
The message is max 18 characters, and is ended by a zero-value

example :

msg @message ;Put "ABC" as the message
...
#message
db 65,66,67,0

You can also:
mov ax, message
msg @ax

The msg instruction is a zero-latency instruktion.
</verb></tscreen>

<sect1>err<p>
err val :
<tscreen><verb>
This instruction sends a message (much like msg) but it looks like this:

example:

err 6 ;Print message "ERROR #: 6"
</verb></tscreen>

<sect1>readfile / writefile
<p>
readfile
writefile
<tscreen><verb>
These instructions lets you access a file on disk.
The file survives between battles, (it has the name of the bot with the
ending .dat)

The size of your file is 64 bytes for every kb of RAM.
That is, a bot wit 4 kb RAM will have 256 bytes on disk.

Writing to the file:
mov ax,(position in file to start in)
mov cx,(number of bytes to write)
mov si,(position in RAM where the data to be written is positioned)
writefile

Reading from the file:
mov ax,(position in file to start)
mov cx,(number of bytes to read)
mov di,(position in RAM to read to)
readfile

ax+cx must not be more than he filesize limit of your bot.

Return value is in ax, and is number of bytes written/read,
or -1 if an error occured

</verb></tscreen>

<sect>"Physical" details of objects<p>

A lot of the specific data, especially for the "devices" is set in the config file,
why this list can't be complete. However some data is still hardcoded into the
code and that is listed here. (In a future version of BattleBots I might move all
of these "constants" into a config file too...)

<sect1>Speeds:<p>
<tscreen><verb>
plasmashot: 256
AS-rocket: 256
Missile: 256
</verb></tscreen>

<sect1>Explosion strength<p>
<tscreen><verb>
plasmashot: 15
mine: 70
AS-rocket: 120-0 (120 at center, 0 at 3000 units)
missile: 175
beam: 7
</verb></tscreen>

<sect1>Heat generated<p>
<tscreen><verb>
firing plasmashot: 45
engine thrust: forward : int(speed/35) backward : int(speed/25)
shield absorbing damage: strength absorbed * 4
using cloak: 5 + points of cloak (each cycle!)
</verb></tscreen>

<sect1>Fuel used<p>
<tscreen><verb>
engine thrust : 1+thrust/10
firing beam : 20
using cloak : 6
using shield : 4
active cooling : 5
</verb></tscreen>

<sect>Questions and Answers<p>

<sect1>Windows version<p>
Q: Will there be a windows version?

A: Not necessarily, but I've now got so many requests for it so I might consider it.
First I shall get version 1.0 of the Linux version out (sometime around March 2001)
then I might consider doing a windows port.

<sect>Credits<p>

During my development of BattleBots I've received help and suggestions from a lot of
people, this is a list of people who's contributions in one form or another is part
of BattleBots:

<verb>
Main programmer/Administrator/Original author etc:

Andreas Agorander (Bluefire@bluefire.nu)

Patches:

Raymond Martineau (dynamo_tamarin@yahoo.com)
Daniel F Moisset (dmoisset@grulic.org.ar)
Andrew P Moise (moise+@andrew.cmu.edu)

"skin" graphics:
David Heremans (david.heremans@siemens.atea.be)

Suggestions/Bugreports/testing:

Richard Löfberg (richard@linux.nu)
Raymond Martineau (dynamo_tamarin@yahoo.com)
Terje Dahlström (e97td@efd.lth.se)
"Caezar" (caezar@flashmail.com)
"Achiles" (achiles@retemail.es)
Sean Lunsford (srlunsford@qwest.net)
Clay Sampson (sampsonc@crosslink.net)
David Heremans (david.heremans@siemens.atea.be)
</verb>


<sect>Copyright<p>

BattleBots Copyright 2000 Andreas Agorander , Bluefire@linux.nu


This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

<p>
</article>
